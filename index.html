<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>The PhishSauce Threat Graph</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root { --bg:#0b0b0c; --fg:#eaeaea; --panel:#16161a; --muted:#9aa0a6; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:Inter,system-ui,Segoe UI,Arial }
    #wrap { display:grid; grid-template-rows:auto auto 1fr; height:100% }
    #loader,#toolbar {
      display:flex; flex-wrap:wrap; gap:12px; align-items:center;
      padding:10px 12px; background:var(--panel); border-bottom:1px solid #222;
    }
    .group { display:flex; align-items:center; gap:8px; background:#1f1f23; padding:6px 8px; border-radius:10px }
    select, input, button { background:#0f0f12; color:var(--fg); border:1px solid #2a2a2f; border-radius:8px; padding:6px 8px }
    button { cursor:pointer }
    label { font-size:12px; color:var(--muted) }
    #graph { height:100%; }
    .hint { font-size:12px; color:var(--muted) }
  </style>
</head>
<body>
<div id="wrap">
  <!-- Loader -->
  <div id="loader">
    <div class="group"><strong>Data:</strong> <span class="hint">Auto-loads <code>graph-export.csv</code> (same folder as this file).</span></div>
    <div class="group"><span id="status" class="hint">Loading…</span></div>
  </div>

  <!-- Filters -->
  <div id="toolbar">
    <div class="group">
      <label>Country</label>
      <select id="country" multiple size="1"></select>
    </div>
    <div class="group" id="nodeTypesBox">
      <label>Node types</label>
    </div>
    <div class="group">
      <label>Relationship types</label>
      <select id="reltype" multiple size="1"></select>
    </div>
    <div class="group">
      <input id="search" placeholder="Search (e.g., Bitter, Vietnam, plugx)" />
      <button id="focusBtn">Focus</button>
      <button id="resetBtn">Reset</button>
    </div>
    <div class="group">
      <label><input type="checkbox" id="neighbors" checked> Show neighbors of matches</label>
    </div>
  </div>

  <div id="graph"></div>
</div>

<script>
/* ---------- helpers ---------- */
const colorBy = {
  ThreatActor:"#ff6b6b", Malware:"#61dafb", Country:"#6ee7b7",
  Tactic:"#fbbf24", Technique:"#c084fc", Infra:"#f472b6",
  Tool:"#60a5fa", Vector:"#f59e0b", Campaign:"#34d399"
};

const LABEL_MAP = {
  "Actor":"ThreatActor",
  "MalwareFamily":"Malware",
  "Technique":"Technique",
  "Tool":"Tool",
  "Infrastructure":"Infra",
  "Region":"Country",
  "Country":"Country",
  "Vector":"Vector",
  "Campaign":"Campaign"
};

const S = (id) => document.getElementById(id);
const setStatus = (t) => S("status").textContent = t;
const normId = (s) => (s||"").toString().trim().toLowerCase()
  .replace(/[^a-z0-9]+/g,"_").replace(/^_|_$/g,"") || "unknown";

/* ---------- state ---------- */
let masterNodes = new Map();   // id -> {id,label,title}
let masterEdges = [];          // {from,to,type}
let labelSet    = new Set();

/* ---------- CSV ---------- */
async function parseCSV(url){
  const r = await fetch(url, {cache: "no-store"});
  if(!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
  const text = await r.text();
  return new Promise((resolve, reject) => {
    Papa.parse(text, { header:true, skipEmptyLines:true,
      complete: (res)=>resolve(res.data), error: reject
    });
  });
}

/* Build graph ONLY from CSV rows (no auto ACTIVE_IN). Also de-dup edges. */
function buildFromGraphExport(rows){
  const N = new Map();
  const E = [];
  const seenEdge = new Set(); // de-dup key: from->to:type

  const addNode = (id, label, title) => { if (!N.has(id)) N.set(id, {id, label, title: String(title||id)}); };
  const addEdge = (a,b,t) => {
    const key = `${a}->${b}:${t||"RELATED"}`;
    if (seenEdge.has(key)) return;
    seenEdge.add(key);
    E.push({from:a,to:b,type:String(t||"RELATED")});
  };

  for (const row of rows){
    const aTitle = row["~start_node_property_name"];
    const aLabelRaw = row["~start_node_labels"];
    const bTitle = row["~end_node_property_name"];
    const bLabelRaw = row["~end_node_labels"];
    const relType = row["~relationship_type"];
    if (!aTitle || !bTitle) continue;

    const aLabel = LABEL_MAP[aLabelRaw] || aLabelRaw || "Node";
    const bLabel = LABEL_MAP[bLabelRaw] || bLabelRaw || "Node";

    const aId = (aLabel === "ThreatActor")
      ? `actor_${normId(aTitle)}`
      : `${normId(aLabel)}_${normId(aTitle)}`;
    const bId = `${normId(bLabel)}_${normId(bTitle)}`;

    addNode(aId, aLabel, aTitle);
    addNode(bId, bLabel, bTitle);
    addEdge(aId, bId, relType);
    labelSet.add(aLabel); labelSet.add(bLabel);
  }

  return {nodes:N, edges:E};
}

/* ---------- UI & graph ---------- */
const nodesDS = new vis.DataSet([]);
const edgesDS = new vis.DataSet([]);
const network = new vis.Network(
  S("graph"),
  { nodes:nodesDS, edges:edgesDS },
  { physics:{solver:"forceAtlas2Based", stabilization:{iterations:200}},
    interaction:{hover:true, tooltipDelay:120} }
);

function populateFilters(){
  // Countries
  const cs = S("country"); cs.innerHTML = "";
  [...new Set([...masterNodes.values()]
    .filter(n=>n.label==="Country").map(n=>n.title))].sort()
    .forEach(c => { const o=document.createElement("option"); o.value=o.textContent=c; cs.appendChild(o); });

  // Relationship types
  const rs = S("reltype"); rs.innerHTML = "";
  [...new Set(masterEdges.map(e=>e.type))].sort()
    .forEach(t => { const o=document.createElement("option"); o.value=o.textContent=t; rs.appendChild(o); });

  // Node types
  const box = S("nodeTypesBox");
  box.querySelectorAll("span,input").forEach(el=>el.remove());
  [...labelSet].sort().forEach(L=>{
    const span=document.createElement("span");
    span.innerHTML=`<input type="checkbox" class="nodetype" value="${L}" checked> ${L}`;
    box.appendChild(span);
  });
}

function applyFilters({focusTerm=null}={}){
  const allowedNodeTypes = new Set(Array.from(document.querySelectorAll(".nodetype:checked")).map(i=>i.value));
  const selectedCountries = new Set(Array.from(S("country").selectedOptions).map(o=>o.value));
  const selectedRelTypes  = new Set(Array.from(S("reltype").selectedOptions).map(o=>o.value));
  const neighbors = S("neighbors").checked;

  let nodeIds = new Set(masterNodes.keys());
  let edges = masterEdges.slice();

  if (selectedRelTypes.size) edges = edges.filter(e => selectedRelTypes.has(e.type));
  nodeIds = new Set([...nodeIds].filter(id => allowedNodeTypes.has(masterNodes.get(id).label)));

  if (selectedCountries.size){
    const cIds = new Set([...masterNodes.values()]
      .filter(n=>n.label==="Country" && selectedCountries.has(n.title)).map(n=>n.id));
    edges = edges.filter(e => cIds.has(e.from) || cIds.has(e.to));
    nodeIds = new Set([...edges.flatMap(e=>[e.from,e.to]), ...cIds]);
  }

  if (focusTerm && focusTerm.trim()){
    const term = focusTerm.toLowerCase();
    const hits = new Set([...masterNodes.values()]
      .filter(n =>
        nodeIds.has(n.id) &&
        ( (n.title||"").toLowerCase().includes(term) ||
          (n.id||"").toLowerCase().includes(term) )
      ).map(n=>n.id)
    );
    if (neighbors){
      edges = edges.filter(e => hits.has(e.from) || hits.has(e.to));
      nodeIds = new Set([...edges.flatMap(e=>[e.from,e.to]), ...hits]);
    } else {
      nodeIds = hits;
      edges = edges.filter(e => hits.has(e.from) && hits.has(e.to));
    }
  }

  nodeIds = new Set([...nodeIds].filter(id => allowedNodeTypes.has(masterNodes.get(id).label)));

  const visNodes = [...nodeIds].map(id => {
    const n = masterNodes.get(id);
    return { id:n.id, label:n.title, group:n.label, shape:"dot", size:12,
      color:{background:colorBy[n.label]||"#d1d5db"}, title:`<b>${n.title}</b><br/>${n.label}` };
  });

  // De-dup edges again at render time (safety)
  const allowed = new Set(visNodes.map(n=>n.id));
  const seen = new Set();
  const visEdges = [];
  for (const e of edges){
    if (!allowed.has(e.from) || !allowed.has(e.to)) continue;
    const key = `${e.from}->${e.to}:${e.type}`;
    if (seen.has(key)) continue;
    seen.add(key);
    visEdges.push({ id:key, from:e.from, to:e.to, label:e.type, arrows:"to",
                    font:{align:"top", size:10}, smooth:true });
  }

  nodesDS.clear(); edgesDS.clear();
  nodesDS.add(visNodes); edgesDS.add(visEdges);
  network.fit({animation:true});
}

function wireFilters(){
  document.addEventListener("change", (e) => {
    if (e.target.classList.contains("nodetype") || e.target.id==="country" || e.target.id==="reltype"){
      applyFilters();
    }
  });
  S("resetBtn").addEventListener("click", () => {
    [...S("country").options].forEach(o=>o.selected=false);
    [...S("reltype").options].forEach(o=>o.selected=false);
    S("search").value=""; S("neighbors").checked=true;
    document.querySelectorAll(".nodetype").forEach(cb=>cb.checked=true);
    applyFilters();
  });
  S("focusBtn").addEventListener("click", () => applyFilters({ focusTerm:S("search").value }));
  S("search").addEventListener("keydown", (e)=>{ if(e.key==="Enter") S("focusBtn").click(); });
}

/* ---------- load & build ---------- */
async function loadRepoCSVs(){
  try{
    setStatus("Loading CSV…");
    const graphRows = await parseCSV("./graph-export.csv");
    const built = buildFromGraphExport(graphRows);
    masterNodes = built.nodes;
    masterEdges = built.edges;
    populateFilters(); wireFilters(); applyFilters();
    setStatus(`Loaded: ${masterNodes.size} nodes, ${masterEdges.length} edges`);
  }catch(e){
    console.error(e);
    setStatus("Load failed: " + (e.message || e));
  }
}

window.addEventListener("load", loadRepoCSVs);
</script>
</body>
</html>
